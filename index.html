<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TAKOTSUBO86</title>
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@200;400;700&display=swap" rel="stylesheet">
  <style>
    .glitch-strip {
  position: absolute;
  z-index: 1400;
  pointer-events: none;
  animation: glitch-strip-flicker 0.3s ease-in-out forwards;
  filter: blur(0.5px);
  mix-blend-mode: lighten;
  transform-origin: center;
}
#asciiRainCanvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 50; /* Sous le poulpe, mais au-dessus du fond */
  pointer-events: none;
  mix-blend-mode: lighten;
  opacity: 0.2;
}

@keyframes glitch-strip-flicker {
  0%   { transform: translateY(0) scale(1); opacity: 0.4; }
  30%  { transform: translateY(-8px) scale(1.05); opacity: 0.7; }
  60%  { transform: translateY(4px) scale(0.95); opacity: 0.3; }
  100% { transform: translateY(0) scale(1); opacity: 0; }
}

/* Formes parasites */
.glitch-strip.line-vert {
  width: 2px;
  height: 40px;
}
.glitch-strip.line-horiz {
  width: 40px;
  height: 2px;
}
.glitch-strip.cube {
  width: 8px;
  height: 8px;
}
.glitch-strip.long-bar {
  width: 2px;
  height: 70px;
}

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      font-family: 'Arial', sans-serif;
      overflow: hidden;
      background: black;
    }
    body {
      background: url('fond_wallpaper_different_perspective.png') no-repeat center center;
      background-size: contain;
      padding: 0 0 120px 0;
      min-height: 100vh;
      position: relative;
    }
    #left-bar, #right-bar {
      position: fixed;
      top: 0;
      height: 100%;
      width: 10vw;
      background: black;
      z-index: 800;
      pointer-events: none;
    }
    #left-bar { left: 0; }
    #right-bar { right: 0; }
    header {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Courier New', monospace;
      font-size: 80px;
      font-weight: bold;
      color: lime;
      text-shadow: 0 0 2px #00ff00, 0 0 5px #00ff00, 0 0 10px #00ff00, 0 0 20px #00ff00;
      animation: glowFlicker 1.2s infinite alternate;
      z-index: 3000;
    }
    @keyframes glowFlicker {
      0% { text-shadow: 0 0 2px #00ff00, 0 0 4px #00ff00, 0 0 6px #00ff00; opacity: 0.95; }
      100% { text-shadow: 0 0 4px #00ff00, 0 0 8px #00ff00, 0 0 14px #00ff00; opacity: 1; }
    }
    #subtitle {
      position: absolute;
      top: 11%;
      left: 75%;
      transform: translateX(-50%);
      background: black;
      padding: 15px 30px;
      color: white;
      font-size: 26px;
      font-weight: bold;
      border-radius: 5px;
      z-index: 1100;
      white-space: pre-line;
      text-align: center;
    }
    .scene-wrapper {
      position: absolute;
      top: 20%;
      left: 0;
      width: 100%;
      height: 60%;
      z-index: 1150;
    }
    .scene-btn {
      all: unset;
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 500px;
      font-family: 'Courier New', monospace;
      font-weight: 300;
      color: lime;
      line-height: 1;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
      z-index: 1500;
      cursor: pointer;
    }
    .scene-btn.left { left: 13vw; }
    .scene-btn.right { right: 13vw; }
    .scene-btn:hover { opacity: 1; }
    .scene-btn::before, .scene-btn::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      background: transparent;
      overflow: hidden;
      clip-path: inset(10% 0 80% 0);
      font-size: inherit;
      font-family: inherit;
      font-weight: inherit;
      line-height: inherit;
      pointer-events: none;
    }
    .scene-btn::before {
      left: 2px;
      color: lime;
      animation: glitch-before 0.2s infinite;
    }
    .scene-btn::after {
      left: -2px;
      color: lime;
      animation: glitch-after 0.15s infinite;
    }
    @keyframes glitch-before {
      0% { clip-path: inset(10% 0 85% 0); }
      50% { clip-path: inset(30% 0 50% 0); }
      100% { clip-path: inset(10% 0 80% 0); }
    }
    @keyframes glitch-after {
      0% { clip-path: inset(80% 0 10% 0); }
      50% { clip-path: inset(60% 0 30% 0); }
      100% { clip-path: inset(70% 0 20% 0); }
    }
    #poulpe {
      position: absolute;
      max-width: 50vw;
      height: auto;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      cursor: grab;
      transition: opacity 0.6s ease;
      animation: floatBig 8s ease-in-out infinite;
      z-index: 1000;
    }

    @keyframes floatBig {
      0%, 100% { transform: translate(-50%, -50%) translateY(0); }
      50% { transform: translate(-50%, -50%) translateY(-20px); }
    }

    .poulpe-clicked {
      animation: shrinkPop 0.4s ease;
    }

    @keyframes shrinkPop {
      0% { transform: translate(-50%, -50%) scale(1); }
      30% { transform: translate(-50%, -50%) scale(0.92); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    .mini-poulpe {
      position: absolute;
      pointer-events: auto;
      opacity: 0.8;
      transition: transform 0.3s ease;
    }

    .mini-poulpe-wrapper {
      position: absolute;
      animation: floatMini 6s ease-in-out infinite;
    }

    @keyframes floatMini {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    #menuToggle {
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 120px;
      height: 120px;
      cursor: pointer;
      z-index: 1300;
      background: none;
      border: none;
      padding: 0;
    }

    .menu-node {
      position: absolute;
      left: 60px;
      bottom: 400px;
      opacity: 0;
      transform: scale(0.5) translateY(0);
      transition: all 0.4s ease;
      background: black;
      padding: 15px 20px;
      font-size: 20px;
      border-radius: 12px;
      box-shadow: 0 0 12px #00000066;
      width: 220px;
      height: 60px;
      color: white;
      z-index: 1250;
    }

    .menu-node.show {
      opacity: 1;
      transform: scale(1) translateY(calc(var(--i) * -100px));
    }

    #alert-tag {
      position: absolute;
      top: 23.5%;
      left: 82%;
      transform: translateX(-100%);
      background: #000;
      padding: 6px 14px;
      font-size: 16px;
      font-weight: bold;
      color: #00ff00;
      border: 2px solid #00ff00;
      border-radius: 6px;
      box-shadow: 0 0 8px #00ff00aa, 0 0 16px #00ff0055 inset;
      font-family: 'Courier New', monospace;
      z-index: 1200;
      animation: blinkDanger 1s infinite alternate;
      white-space: nowrap;
    }

    @keyframes blinkDanger {
      0% { opacity: 1; transform: translateX(-50%) scale(1); }
      100% { opacity: 0.6; transform: translateX(-50%) scale(1.04); }
    }

    #fade-layer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(45deg, #000, #000 5px, #111 5px, #111 10px);
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
    }

    #bottom-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 120px;
      background: black;
      z-index: 500;
    }

    /* Responsive styles (déjà vus précédemment) */
    @media screen and (max-width: 768px) {
      .scene-btn {
        font-size: 120px;
        opacity: 0.6 !important;
        pointer-events: auto;
      }
      .scene-btn.left { left: 5vw; }
      .scene-btn.right { right: 5vw; }
      #subtitle {
        top: 8%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 20px;
        padding: 10px 20px;
      }
      header {
        font-size: 50px;
      }
      #alert-tag {
        top: 18%;
        font-size: 14px;
        padding: 4px 10px;
      }
      .menu-node {
        font-size: 16px;
        width: 180px;
        height: 50px;
      }
      #menuToggle {
        width: 80px;
        height: 80px;
      }
    }
  </style>
</head>
<body>
  <header>TAKOTSUBO86</header>
  <div id="alert-tag">[⚠ INCOMING MODULE]</div>
  <div id="subtitle">Project :<br>ヴォイドスタティック x タコツボ 86</div>
  <img id="poulpe" src="TSUBO_bUtton.png" alt="Poulpe" />
  <div class="scene-wrapper">
    <button class="scene-btn left" onclick="transitionScene(-1)" data-text="{">{</button>
    <button class="scene-btn right" onclick="transitionScene(1)" data-text="}">}</button>
  </div>
  <div id="mini-poulpes"></div>
  <img id="menuToggle" src="animated_eye_cleaned_loop.gif" alt="Menu Eye" />
  <div class="menu-node" style="--i:0">Home</div>
  <div class="menu-node" style="--i:1">Music</div>
  <div class="menu-node" style="--i:2">Gallery</div>
  <div class="menu-node" style="--i:3">Videos</div>
  <div class="menu-node" style="--i:4">Contact</div>
  <div id="fade-layer"></div>
  <div id="bottom-bar"></div>
  <div id="left-bar"></div>
  <div id="right-bar"></div>
<script>
  // === Gestion swipe mobile ===
  let touchStartX = 0;
  let touchEndX = 0;

  function checkSwipe() {
    if (touchEndX < touchStartX - 50) transitionScene(1);   // Swipe gauche
    if (touchEndX > touchStartX + 50) transitionScene(-1);  // Swipe droite
  }

  document.addEventListener('touchstart', e => {
    touchStartX = e.changedTouches[0].screenX;
  });

  document.addEventListener('touchend', e => {
    touchEndX = e.changedTouches[0].screenX;
    checkSwipe();
  });

  // === Menu Toggle ===
  const toggle = document.getElementById("menuToggle");
  const nodes = document.querySelectorAll(".menu-node");
  let menuOpen = false;
  toggle.addEventListener("click", () => {
    menuOpen = !menuOpen;
    nodes.forEach((node, i) => {
      setTimeout(() => {
        node.classList.toggle("show", menuOpen);
      }, i * 100);
    });
  });

  // === Scènes ===
  const scenes = [
  {
    background: 'fond_wallpaper_different_perspective.png',
    poulpe: 'TSUBO_bUtton.png',
    miniPoulpe: 'TSUBO_bUtton.png'
  },
  {
    background: 'fond_wallpaper_scene2.png',
    poulpe: 'TSUBO_scene2.png',
    miniPoulpe: 'TSUBO_scene2.png'
  },
  {
    background: 'fond_tsubogyas.png',
    poulpe: 'tsubo_thinking.png',
    miniPoulpe: 'tsubo_thinking.png'
  }
];

  let currentScene = 0;

  function transitionScene(dir) {
    const fade = document.getElementById("fade-layer");
    fade.style.opacity = 1;

    setTimeout(() => {
      currentScene = (currentScene + dir + scenes.length) % scenes.length;
      const scene = scenes[currentScene];
      document.body.style.background = `black url('${scene.background}') no-repeat center center`;
      document.body.style.backgroundSize = 'contain';
      document.getElementById("poulpe").src = scene.poulpe;
      
      const miniContainer = document.getElementById("mini-poulpes");
      const player = document.getElementById("tsuboPlayer");

if (scene.poulpe.includes("tsubo_thinking")) {
  player.style.display = "block";
  player.play().catch(e => {
    // auto-play bloqué, on laisse l’utilisateur cliquer
    console.log("Audio autoplay bloqué", e);
  });
} else {
  player.pause();
  player.currentTime = 0;
  player.style.display = "none";
}
 
miniContainer.innerHTML = ''; // On vide les mini poulpes

if (scene.miniPoulpe !== 'tsubo_thinking.png') {
  for (let i = 0; i < 86; i++) {
    const mini = document.createElement("img");
    mini.src = scene.miniPoulpe;
    mini.classList.add("mini-poulpe");
    const size = 40 + Math.random() * 40;
    mini.style.width = `${size}px`;

    let x, y, tries = 0;
    do {
      x = Math.random() * (window.innerWidth - size);
      y = Math.random() * (window.innerHeight - 120 - size);
      tries++;
    } while (isOverlapping(x, y, size) && tries < 100);

    mini.style.left = `${x}px`;
    mini.style.top = `${y}px`;
    mini.style.position = "absolute";
    mini.style.transform = `rotate(${Math.random() * 360}deg)`;
    mini.style.cursor = "grab";

    if (i === 13) {
      mini.style.cursor = "pointer";
      mini.style.filter = "hue-rotate(70deg) saturate(1.2)";
      mini.addEventListener("click", () => {
        window.location.href = "secret.html";
      });
    }

    miniContainer.appendChild(mini);
  }
}

      fade.style.opacity = 0;
    }, 400);
  }

  // === Animation du gros poulpe ===
  const poulpe = document.getElementById("poulpe");
  poulpe.addEventListener("click", () => {
    poulpe.classList.remove("poulpe-clicked");
    void poulpe.offsetWidth;
    poulpe.classList.add("poulpe-clicked");
    setTimeout(() => poulpe.classList.remove("poulpe-clicked"), 400);
  });
  const miniContainer = document.getElementById("mini-poulpes");
  const screenW = window.innerWidth;
  const screenH = window.innerHeight;
  const positions = [];

  function isOverlapping(x, y, size) {
    return positions.some(pos => {
      const dx = pos.x - x;
      const dy = pos.y - y;
      return Math.sqrt(dx * dx + dy * dy) < (pos.size + size) / 2;
    }) || Math.sqrt(Math.pow(x - screenW/2, 2) + Math.pow(y - screenH/2, 2)) < 150;
  }

  for (let i = 0; i < 86; i++) {
    const wrapper = document.createElement("div");
    wrapper.classList.add("mini-poulpe-wrapper");

    const mini = document.createElement("img");
    mini.src = scenes[currentScene].miniPoulpe;
    mini.classList.add("mini-poulpe");

    const size = 40 + Math.random() * 40;
    mini.style.width = `${size}px`;

    let x, y, tries = 0;
    do {
      x = Math.random() * (screenW - size);
      y = Math.random() * (screenH - 120 - size);
      tries++;
    } while (isOverlapping(x, y, size) && tries < 100);

    positions.push({ x, y, size });
    wrapper.style.left = `${x}px`;
    wrapper.style.top = `${y}px`;
    mini.style.transform = `rotate(${Math.random() * 360}deg)`;
    mini.style.cursor = "grab";

    // Secret poulpe
    if (i === 13) {
      mini.style.cursor = "pointer";
      mini.style.filter = "hue-rotate(70deg) saturate(1.2)";
      mini.addEventListener("click", () => {
        window.location.href = "secret.html";
      });
    }

    // Drag & retour
    mini.addEventListener("mousedown", (e) => {
      let offsetX = e.clientX - wrapper.offsetLeft;
      let offsetY = e.clientY - wrapper.offsetTop;
      function moveAt(e) {
        wrapper.style.left = `${e.clientX - offsetX}px`;
        wrapper.style.top = `${e.clientY - offsetY}px`;
      }
      function onMove(e) { moveAt(e); }
      function onUp() {
        document.removeEventListener("mousemove", onMove);
        document.removeEventListener("mouseup", onUp);
        setTimeout(() => {
          wrapper.style.left = `${x}px`;
          wrapper.style.top = `${y}px`;
        }, 6000);
      }
      document.addEventListener("mousemove", onMove);
      document.addEventListener("mouseup", onUp);
    });

    wrapper.appendChild(mini);
    miniContainer.appendChild(wrapper);
  }

  // Réaction à la souris : les poulpes fuient
  document.addEventListener("mousemove", (e) => {
    document.querySelectorAll(".mini-poulpe").forEach(p => {
      const rect = p.getBoundingClientRect();
      const dx = e.clientX - (rect.left + rect.width / 2);
      const dy = e.clientY - (rect.top + rect.height / 2);
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 100) {
        const angle = Math.atan2(dy, dx);
        p.style.transform = `translate(${-Math.cos(angle)*30}px, ${-Math.sin(angle)*30}px) rotate(${Math.random()*360}deg)`;
      } else {
        p.style.transform = `translate(0, 0) rotate(${Math.random()*360}deg)`;
      }
    });
  });
  // === Génération des glitch strips sur les flèches ===
  function spawnGlitchStrips(button) {
    const colors = ["#00ffee", "#ff00ff", "#ffffff", "#ff4444", "#88faff"];
    const shapes = ["line-vert", "line-horiz", "cube", "long-bar"];
    for (let i = 0; i < 4 + Math.floor(Math.random() * 4); i++) {
      const strip = document.createElement("div");
      strip.classList.add("glitch-strip", shapes[Math.floor(Math.random() * shapes.length)]);
      strip.style.background = colors[Math.floor(Math.random() * colors.length)];
      strip.style.opacity = (0.3 + Math.random() * 0.6).toFixed(2);
      const side = Math.random() < 0.5 ? 'left' : 'right';
      const offsetX = side === 'left' ? -20 - Math.random() * 20 : button.offsetWidth + 10 + Math.random() * 20;
      const offsetY = Math.random() * button.offsetHeight;
      strip.style.left = `${offsetX}px`;
      strip.style.top = `${offsetY}px`;
      button.appendChild(strip);
      setTimeout(() => strip.remove(), 300 + Math.random() * 400);
    }
  }

  // Activation du glitch en hover
  document.querySelectorAll(".scene-btn").forEach(btn => {
    btn.addEventListener("mouseenter", () => {
      spawnGlitchStrips(btn);
      const interval = setInterval(() => {
        if (!btn.matches(":hover")) clearInterval(interval);
        else spawnGlitchStrips(btn);
      }, 400 + Math.random() * 300);
    });
  });

  // Affichage conditionnel des flèches au hover (hors mobile)
  const wrapperElem = document.querySelector('.scene-wrapper');
  const buttons = document.querySelectorAll('.scene-btn');
  let hideTimer = null;

  wrapperElem.addEventListener('mouseenter', () => {
    clearTimeout(hideTimer);
    buttons.forEach(btn => {
      btn.style.opacity = 0.6;
      btn.style.pointerEvents = 'auto';
    });
  });

  wrapperElem.addEventListener('mouseleave', () => {
    if (window.innerWidth > 768) {
      hideTimer = setTimeout(() => {
        buttons.forEach(btn => {
          btn.style.opacity = 0;
          btn.style.pointerEvents = 'none';
        });
      }, 2000);
    }
  });
  const canvas = document.getElementById('asciiRainCanvas');
const ctx = canvas.getContext('2d');

const mots = [
  'coeur', 'sens', 'sourire', 'solitude', 'poids', 'regard', 'parole',
  '心', '感覚', '孤独', '微笑み', '言葉', '重さ', '視線'
];

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const fontSize = 18;
const columns = Math.floor(canvas.width / fontSize);
const drops = Array(columns).fill(1);

ctx.font = `${fontSize}px monospace`;

function drawAsciiRain() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < drops.length; i++) {
    const text = mots[Math.floor(Math.random() * mots.length)];
    const x = i * fontSize;
    const y = drops[i] * fontSize;

    ctx.fillStyle = '#00ffaa';
    ctx.fillText(text, x, y);

    if (y > canvas.height && Math.random() > 0.975) drops[i] = 0;
    drops[i]++;
  }
}

let rainInterval = null;

function startAsciiRain() {
  if (!rainInterval) {
    rainInterval = setInterval(drawAsciiRain, 60);
  }
}

function stopAsciiRain() {
  clearInterval(rainInterval);
  rainInterval = null;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

</script>
<canvas id="asciiRainCanvas"></canvas>
<audio id="tsuboPlayer" controls style="position:fixed; bottom:150px; right:30px; z-index:3000; display:none;">
  <source src="m9_site.wav" type="audio/mpeg">
  <audio id="tsuboPlayer" src="SON_TSUBO.mp3" loop autoplay></audio>
  Votre navigateur ne supporte pas l'audio.
</audio>
</body>
</html>

