<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TAKOTSUBO86</title>
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@200;400;700&display=swap" rel="stylesheet">
  <style>
    .glitch-strip {
  position: absolute;
  z-index: 1400;
  pointer-events: none;
  animation: glitch-strip-flicker 0.3s ease-in-out forwards;
  filter: blur(0.5px);
  mix-blend-mode: lighten;
  transform-origin: center;
}
@keyframes glitch-strip-flicker {
  0%   { transform: translateY(0) scale(1); opacity: 0.4; }
  30%  { transform: translateY(-8px) scale(1.05); opacity: 0.7; }
  60%  { transform: translateY(4px) scale(0.95); opacity: 0.3; }
  100% { transform: translateY(0) scale(1); opacity: 0; }
}

/* Formes parasites */
.glitch-strip.line-vert {
  width: 2px;
  height: 40px;
}
.glitch-strip.line-horiz {
  width: 40px;
  height: 2px;
}
.glitch-strip.cube {
  width: 8px;
  height: 8px;
}
.glitch-strip.long-bar {
  width: 2px;
  height: 70px;
}

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      font-family: 'Arial', sans-serif;
      overflow: hidden;
      background: black;
    }
    body {
      background: url('fond_wallpaper_different_perspective.png') no-repeat center center;
      background-size: cover;
      padding: 0 0 120px 0;
      min-height: 100vh;
      position: relative;
    }
    #left-bar, #right-bar {
      position: fixed;
      top: 0;
      height: 100%;
      width: 10vw;
      background: black;
      z-index: 800;
      pointer-events: none;
    }
    #left-bar { left: 0; }
    #right-bar { right: 0; }
    header {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Courier New', monospace;
      font-size: 80px;
      font-weight: bold;
      color: lime;
      text-shadow: 0 0 2px #00ff00, 0 0 5px #00ff00, 0 0 10px #00ff00, 0 0 20px #00ff00;
      animation: glowFlicker 1.2s infinite alternate;
      z-index: 3000;
    }
    @keyframes glowFlicker {
      0% { text-shadow: 0 0 2px #00ff00, 0 0 4px #00ff00, 0 0 6px #00ff00; opacity: 0.95; }
      100% { text-shadow: 0 0 4px #00ff00, 0 0 8px #00ff00, 0 0 14px #00ff00; opacity: 1; }
    }
    #subtitle {
      position: absolute;
      top: 11%;
      left: 75%;
      transform: translateX(-50%);
      background: black;
      padding: 15px 30px;
      color: white;
      font-size: 26px;
      font-weight: bold;
      border-radius: 5px;
      z-index: 1100;
      white-space: pre-line;
      text-align: center;
    }
    .scene-wrapper {
      position: absolute;
      top: 20%;
      left: 0;
      width: 100%;
      height: 60%;
      z-index: 1150;
    }
    .scene-btn {
      all: unset;
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size:  18vw;
      font-family: 'Courier New', monospace;
      font-weight: 300;
      color: rgba(174, 179, 219, 0.247);
      line-height: 1;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
      z-index: 1500;
      cursor: pointer;
    }
    .scene-btn.left { left: 13vw; }
    .scene-btn.right { right: 13vw; }
    .scene-btn:hover { opacity: 1; }
    .scene-btn::before, .scene-btn::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      background: transparent;
      overflow: hidden;
      clip-path: inset(10% 0 80% 0);
      font-size: inherit;
      font-family: inherit;
      font-weight: inherit;
      line-height: inherit;
      pointer-events: none;
    }
    .scene-btn::before {
  left: 2px;
  color: rgba(174, 179, 219, 0.247); /* valeur initiale, sera override par l‚Äôanimation */
  animation: glitch-before 0.2s infinite, colorShift 1.2s infinite linear;
}

.scene-btn::after {
  left: -2px;
  color: rgba(174, 179, 219, 0.247); /* idem */
  animation: glitch-after 0.15s infinite, colorShift 1s infinite linear;
}
@keyframes colorShift {
  0%   { color: #00ffee; }
  25%  { color: #ff00ff; }
  50%  { color: #88faff; }
  75%  { color: #ff4444; }
  100% { color: #00ffee; }
}
    @keyframes glitch-before {
      0% { clip-path: inset(10% 0 85% 0); }
      50% { clip-path: inset(30% 0 50% 0); }
      100% { clip-path: inset(10% 0 80% 0); }
    }
    @keyframes glitch-after {
      0% { clip-path: inset(80% 0 10% 0); }
      50% { clip-path: inset(60% 0 30% 0); }
      100% { clip-path: inset(70% 0 20% 0); }
    }
    #poulpe {
      position: absolute;
      max-width: 50vw;
      height: auto;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      cursor: grab;
      transition: opacity 0.6s ease;
      animation: floatBig 8s ease-in-out infinite;
      z-index: 1000;
    }

    @keyframes floatBig {
      0%, 100% { transform: translate(-50%, -50%) translateY(0); }
      50% { transform: translate(-50%, -50%) translateY(-20px); }
    }

    .poulpe-clicked {
      animation: shrinkPop 0.4s ease;
    }

    @keyframes shrinkPop {
      0% { transform: translate(-50%, -50%) scale(1); }
      30% { transform: translate(-50%, -50%) scale(0.92); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    .mini-poulpe {
      position: absolute;
      pointer-events: auto;
      opacity: 0.8;
      transition: transform 0.3s ease;
    }

    .mini-poulpe-wrapper {
      position: absolute;
      animation: floatMini 6s ease-in-out infinite;
    }

    @keyframes floatMini {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    #menuToggle {
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 120px;
      height: 120px;
      cursor: pointer;
      z-index: 1300;
      background: none;
      border: none;
      padding: 0;
    }
    .menu-node {
  position: absolute;
  left: 1vw; /* position horizontale en % de largeur √©cran */
  bottom: 35vh; /* position verticale en % de hauteur √©cran */
  opacity: 0;
  transform: scale(0.5) translateY(0);
  transition: all 0.4s ease;
  background: black;
  padding: 2vh 3vw;
  font-size: 1vw; /* taille texte dynamique */
  border-radius: 1vw;
  box-shadow: 0 0 1vw #00000066;
  width: 7vw; /* largeur responsive */
  height: 3vh;  /* hauteur responsive */
  color: white;
  z-index: 1250;
}
    .menu-node.show {
      opacity: 1;
      transform: scale(1) translateY(calc(var(--i) * -6vh)); /* avant c'√©tait -100px */
    }

    #alert-tag {
      position: absolute;
      top: 23.5%;
      left: 82%;
      transform: translateX(-100%);
      background: #000;
      padding: 6px 14px;
      font-size: 16px;
      font-weight: bold;
      color: #00ff00;
      border: 2px solid #00ff00;
      border-radius: 6px;
      box-shadow: 0 0 8px #00ff00aa, 0 0 16px #00ff0055 inset;
      font-family: 'Courier New', monospace;
      z-index: 1200;
      animation: blinkDanger 1s infinite alternate;
      white-space: nowrap;
      display: none; /* cach√© par d√©faut */
    }

    @keyframes blinkDanger {
      0% { opacity: 1; transform: translateX(-50%) scale(1); }
      100% { opacity: 0.6; transform: translateX(-50%) scale(1.04); }
    }

    #fade-layer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(45deg, #000, #000 5px, #111 5px, #111 10px);
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
    }

    #bottom-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 20px;
      background: black;
      z-index: 500;
    }

    /* Responsive styles (d√©j√† vus pr√©c√©demment) */
    @media screen and (max-width: 768px) {
      .scene-btn {
        font-size: 120px;
        opacity: 0.6 !important;
        pointer-events: auto;
      }
      .scene-btn.left { left: 5vw; }
      .scene-btn.right { right: 5vw; }
      #subtitle {
        top: 8%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 20px;
        padding: 10px 20px;
      }
      header {
        font-size: 50px;
      }
      #alert-tag {
        top: 18%;
        font-size: 14px;
        padding: 4px 10px;
      }
      .menu-node {
  width: 24vw;
  height: 5vh;
  font-size: 3.5vw;
  padding: 1.2vh 2vw;
      }
      #menuToggle {
        width: 80px;
        height: 80px;
      }
    }
  </style>
</head>
<body>
  <header>TAKOTSUBO86</header>
  <div id="alert-tag">[‚ö† INCOMING MODULE]</div>
  <div id="subtitle">Project :<br>„É¥„Ç©„Ç§„Éâ„Çπ„Çø„ÉÜ„Ç£„ÉÉ„ÇØ x „Çø„Ç≥„ÉÑ„Éú 86</div>
  <img id="poulpe" src="TSUBO_bUtton.png" alt="Poulpe" />
  <div class="scene-wrapper">
    <button class="scene-btn left" onclick="transitionScene(-1)" data-text="{">{</button>
    <button class="scene-btn right" onclick="transitionScene(1)" data-text="}">}</button>
  </div>
  <div id="mini-poulpes"></div>
  <img id="menuToggle" src="animated_eye_cleaned_loop.gif" alt="Menu Eye" />
  <div class="menu-node" style="--i:0">Home</div>
  <div class="menu-node" style="--i:2">Gallery</div>
  <div class="menu-node" style="--i:4">Contact</div>
  <div id="fade-layer"></div>
  <div id="bottom-bar"></div>
  <div id="left-bar"></div>
  <div id="right-bar"></div>
<script>
  // === Gestion swipe mobile ===
  let touchStartX = 0;
  let touchEndX = 0;

  function checkSwipe() {
    if (touchEndX < touchStartX - 50) transitionScene(1);   // Swipe gauche
    if (touchEndX > touchStartX + 50) transitionScene(-1);  // Swipe droite
  }

  document.addEventListener('touchstart', e => {
    touchStartX = e.changedTouches[0].screenX;
  });

  document.addEventListener('touchend', e => {
    touchEndX = e.changedTouches[0].screenX;
    checkSwipe();
  });

  // === Menu Toggle ===
  const toggle = document.getElementById("menuToggle");
  const nodes = document.querySelectorAll(".menu-node");
  let menuOpen = false;
  toggle.addEventListener("click", () => {
    menuOpen = !menuOpen;
    nodes.forEach((node, i) => {
      setTimeout(() => {
        node.classList.toggle("show", menuOpen);
      }, i * 100);
    });
  });

  // === Sc√®nes ===
  const scenes = [
  {
    background: 'fond_wallpaper_different_perspective.png',
    poulpe: 'TSUBO_bUtton.png',
    miniPoulpe: 'TSUBO_bUtton.png'
  },
  {
    background: 'fond_wallpaper_scene2.png',
    poulpe: 'TSUBO_scene2.png',
    miniPoulpe: 'TSUBO_scene2.png'
  },
  {
    background: 'fond_tsubogyas.png',
    poulpe: 'tsubo_thinking.png',
    miniPoulpe: 'tsubo_thinking.png'
  }
];

  let currentScene = 0;

  function transitionScene(dir) {
    const fade = document.getElementById("fade-layer");
    fade.style.opacity = 1;

    setTimeout(() => {
      currentScene = (currentScene + dir + scenes.length) % scenes.length;
      const scene = scenes[currentScene];
      // Gestion de l'affichage du player YouTube
const ytContainer = document.getElementById("youtube-container");
const ytButton = document.getElementById("yt-play-button");

if (scene.poulpe === "TSUBO_bUtton.png") {
  ytContainer.style.display = "block";
  ytButton.style.display = "block";
} else {
  ytContainer.style.display = "none";
  ytButton.style.display = "none";
  if (ytPlayer && typeof ytPlayer.pauseVideo === "function") {
    ytPlayer.pauseVideo();
  }
}

      document.body.style.background = `url('${scene.background}') no-repeat center center`;
      document.body.style.backgroundSize = 'cover';
      document.getElementById("poulpe").src = scene.poulpe;

      const subtitle = document.getElementById("subtitle");
if (scene.poulpe === "TSUBO_bUtton.png") {
  subtitle.style.display = "block";
} else {
  subtitle.style.display = "none";
}

// Activation de l'effet ASCII uniquement sur tsubo_thinking
if (scene.poulpe.includes("tsubo_thinking")) {
  document.getElementById("asciiCanvas").style.display = "block";
  startAsciiRain();
} else {
  document.getElementById("asciiCanvas").style.display = "none";
  stopAsciiRain();
}
      const youtube = document.getElementById("youtube-container");
if (scene.poulpe === "TSUBO_bUtton.png") {
  youtube.style.display = "block";
} else {
  youtube.style.display = "none";
}
      const miniContainer = document.getElementById("mini-poulpes");
      const player = document.getElementById("tsuboPlayer");

if (scene.poulpe.includes("tsubo_thinking")) {
  player.style.display = "block";
  player.style.bottom = "50px";
  player.play().catch(e => {
    // auto-play bloqu√©, on laisse l‚Äôutilisateur cliquer
    console.log("Audio autoplay bloqu√©", e);
  });
} else {
  player.pause();
  player.currentTime = 0;
  player.style.display = "none";
}
const alertTag = document.getElementById("alert-tag");
if (scene.poulpe.includes("tsubo_thinking")) {
  alertTag.style.display = "block";
} else {
  alertTag.style.display = "none";
}
miniContainer.innerHTML = ''; // On vide les mini poulpes

if (scene.miniPoulpe !== 'tsubo_thinking.png') {
  for (let i = 0; i < 86; i++) {
    const mini = document.createElement("img");
    mini.src = scene.miniPoulpe;
    mini.classList.add("mini-poulpe");
    const size = 40 + Math.random() * 40;
    mini.style.width = `${size}px`;

    let x, y, tries = 0;
    do {
      x = Math.random() * (window.innerWidth - size);
      y = Math.random() * (window.innerHeight - 120 - size);
      tries++;
    } while (isOverlapping(x, y, size) && tries < 100);

    mini.style.left = `${x}px`;
    mini.style.top = `${y}px`;
    mini.style.position = "absolute";
    mini.style.transform = `rotate(${Math.random() * 360}deg)`;
    mini.style.cursor = "grab";

    if (i === 13) {
      mini.style.cursor = "pointer";
      mini.style.filter = "hue-rotate(70deg) saturate(1.2)";
      mini.addEventListener("click", () => {
        window.location.href = "secret.html";
      });
    }

    miniContainer.appendChild(mini);
  }
}

      fade.style.opacity = 0;
    }, 400);
  }

  // === Animation du gros poulpe ===
  const poulpe = document.getElementById("poulpe");
  poulpe.addEventListener("click", () => {
    poulpe.classList.remove("poulpe-clicked");
    void poulpe.offsetWidth;
    poulpe.classList.add("poulpe-clicked");
    setTimeout(() => poulpe.classList.remove("poulpe-clicked"), 400);
  });
  const miniContainer = document.getElementById("mini-poulpes");
  const screenW = window.innerWidth;
  const screenH = window.innerHeight;
  const positions = [];

  function isOverlapping(x, y, size) {
    return positions.some(pos => {
      const dx = pos.x - x;
      const dy = pos.y - y;
      return Math.sqrt(dx * dx + dy * dy) < (pos.size + size) / 2;
    }) || Math.sqrt(Math.pow(x - screenW/2, 2) + Math.pow(y - screenH/2, 2)) < 150;
  }

  for (let i = 0; i < 86; i++) {
    const wrapper = document.createElement("div");
    wrapper.classList.add("mini-poulpe-wrapper");

    const mini = document.createElement("img");
    mini.src = scenes[currentScene].miniPoulpe;
    mini.classList.add("mini-poulpe");

    const size = 40 + Math.random() * 40;
    mini.style.width = `${size}px`;

    let x, y, tries = 0;
    do {
      x = Math.random() * (screenW - size);
      y = Math.random() * (screenH - 120 - size);
      tries++;
    } while (isOverlapping(x, y, size) && tries < 100);

    positions.push({ x, y, size });
    wrapper.style.left = `${x}px`;
    wrapper.style.top = `${y}px`;
    mini.style.transform = `rotate(${Math.random() * 360}deg)`;
    mini.style.cursor = "grab";

    // Secret poulpe
    if (i === 13) {
      mini.style.cursor = "pointer";
      mini.style.filter = "hue-rotate(70deg) saturate(1.2)";
      mini.addEventListener("click", () => {
        window.location.href = "secret.html";
      });
    }

    // Drag & retour
    mini.addEventListener("mousedown", (e) => {
      let offsetX = e.clientX - wrapper.offsetLeft;
      let offsetY = e.clientY - wrapper.offsetTop;
      function moveAt(e) {
        wrapper.style.left = `${e.clientX - offsetX}px`;
        wrapper.style.top = `${e.clientY - offsetY}px`;
      }
      function onMove(e) { moveAt(e); }
      function onUp() {
        document.removeEventListener("mousemove", onMove);
        document.removeEventListener("mouseup", onUp);
        setTimeout(() => {
          wrapper.style.left = `${x}px`;
          wrapper.style.top = `${y}px`;
        }, 6000);
      }
      document.addEventListener("mousemove", onMove);
      document.addEventListener("mouseup", onUp);
    });

    wrapper.appendChild(mini);
    miniContainer.appendChild(wrapper);
  }

  // R√©action √† la souris : les poulpes fuient
  document.addEventListener("mousemove", (e) => {
    document.querySelectorAll(".mini-poulpe").forEach(p => {
      const rect = p.getBoundingClientRect();
      const dx = e.clientX - (rect.left + rect.width / 2);
      const dy = e.clientY - (rect.top + rect.height / 2);
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 100) {
        const angle = Math.atan2(dy, dx);
        p.style.transform = `translate(${-Math.cos(angle)*30}px, ${-Math.sin(angle)*30}px) rotate(${Math.random()*360}deg)`;
      } else {
        p.style.transform = `translate(0, 0) rotate(${Math.random()*360}deg)`;
      }
    });
  });
  // === G√©n√©ration des glitch strips sur les fl√®ches ===
  function spawnGlitchStrips(button) {
    const colors = ["#00ffee", "#ff00ff", "#ffffff", "#ff4444", "#88faff"];
    const shapes = ["line-vert", "line-horiz", "cube", "long-bar"];
    for (let i = 0; i < 4 + Math.floor(Math.random() * 4); i++) {
      const strip = document.createElement("div");
      strip.classList.add("glitch-strip", shapes[Math.floor(Math.random() * shapes.length)]);
      strip.style.background = colors[Math.floor(Math.random() * colors.length)];
      strip.style.opacity = (0.3 + Math.random() * 0.6).toFixed(2);
      const side = Math.random() < 0.5 ? 'left' : 'right';
      const offsetX = side === 'left' ? -20 - Math.random() * 20 : button.offsetWidth + 10 + Math.random() * 20;
      const offsetY = Math.random() * button.offsetHeight;
      strip.style.left = `${offsetX}px`;
      strip.style.top = `${offsetY}px`;
      button.appendChild(strip);
      setTimeout(() => strip.remove(), 300 + Math.random() * 400);
    }
  }

  // Activation du glitch en hover
  document.querySelectorAll(".scene-btn").forEach(btn => {
    btn.addEventListener("mouseenter", () => {
      spawnGlitchStrips(btn);
      const interval = setInterval(() => {
        if (!btn.matches(":hover")) clearInterval(interval);
        else spawnGlitchStrips(btn);
      }, 400 + Math.random() * 300);
    });
  });

  // Affichage conditionnel des fl√®ches au hover (hors mobile)
  const wrapperElem = document.querySelector('.scene-wrapper');
  const buttons = document.querySelectorAll('.scene-btn');
  let hideTimer = null;

  wrapperElem.addEventListener('mouseenter', () => {
    clearTimeout(hideTimer);
    buttons.forEach(btn => {
      btn.style.opacity = 0.6;
      btn.style.pointerEvents = 'auto';
    });
  });

  wrapperElem.addEventListener('mouseleave', () => {
    if (window.innerWidth > 768) {
      hideTimer = setTimeout(() => {
        buttons.forEach(btn => {
          btn.style.opacity = 0;
          btn.style.pointerEvents = 'none';
        });
      }, 2000);
    }
  });
</script>
<audio id="tsuboPlayer" controls style="position:fixed; bottom:150px; right:30px; z-index:3000; display:none;">
  <source src="m9_site.wav" type="audio/mpeg">
  <audio id="tsuboPlayer" src="SON_TSUBO.mp3" loop autoplay></audio>
  Votre navigateur ne supporte pas l'audio.
</audio>
<!-- Conteneur vid√©o vide (l‚ÄôAPI YouTube injectera l‚Äôiframe ici) -->
<div id="youtube-container" style="
  position: fixed;
  top: 88%;
  left: 80%;
  transform: translate(-50%, -50%);
  z-index: 2100;
  border: 2px solid lime;
  box-shadow: 0 0 15px #00ff00aa;
  border-radius: 10px;
  overflow: hidden;
  width: 280px;
  height: 158px;
  display: none;
"></div>

<!-- Bouton PLAY -->
<button id="yt-play-button" style="
  position: fixed;
  top: 88%;
  left: 80%;
  transform: translate(-50%, -50%);
  z-index: 2200;
  background: black;
  color: lime;
  border: 2px solid lime;
  padding: 10px 20px;
  font-family: 'Courier New', monospace;
  font-size: 16px;
  border-radius: 6px;
  cursor: pointer;
  box-shadow: 0 0 10px #00ff00;
  display: none;
">
  ‚ñ∂ PLAY MODULE
</button>

<script>
  let ytPlayer;
  function onYouTubeIframeAPIReady() {
    ytPlayer = new YT.Player('youtube-container', {
      height: '158',
      width: '280',
      videoId: 'C0nXqL9jrE0',
      playerVars: {
        autoplay: 0,
        controls: 1,
        rel: 0,
        loop: 1,
        playlist: 'C0nXqL9jrE0'
      },
      events: {
        'onReady': function () {
          document.getElementById("yt-play-button").style.display = "block";
        }
      }
    });
  }

  document.getElementById("yt-play-button").addEventListener("click", function () {
    this.style.display = "none";
    if (ytPlayer) {
      ytPlayer.playVideo();
    }
  });

  const tag = document.createElement('script');
  tag.src = "https://www.youtube.com/iframe_api";
  document.body.appendChild(tag);
</script>
<canvas id="asciiCanvas" style="
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 60;
  pointer-events: none;
  background: transparent;
"></canvas>
<script>
  const canvas = document.getElementById("asciiCanvas");
  const ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const jpWords = ["„Åì„Åì„Çç", "„Åü„ÇÅ„ÅÑ„Åç", "„Åó„Åö„Åã", "„Åï„Åå„Åó„Å¶", "„Åö„Çå", "„Å≤„Åã„Çä", "„Åì„Åà", "„ÇÜ„Å£„Åè„Çä", "„Åã„Åí"];
  const frWords = ["coeur", "vide", "douceur", "fragile", "voix", "ombre", "retour", "absence", "lentement"];
  const allWords = [...jpWords, ...frWords];
  const fontSize = 22;
  const columns = Math.floor(canvas.width / fontSize);
  let drops = Array(columns).fill(1);
  ctx.font = `${fontSize}px 'Source Code Pro', monospace`;

  // üíô Ici tu ajoutes la palette :
  const palette = [
    "#0D1B2A",  // bleu nuit profond
    "#1B263B",  // bleu acier
    "#415A77",  // bleu-gris
    "#5A4E7C",  // mauve d√©satur√©
    "#6D597A",  // mauve-gris
    "#8D6BB0",  // mauve plus vif
    "#A26DD8"   // mauve √©lectrique l√©ger
  ];

  let asciiInterval;

  function drawRain() {
    ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let i = 0; i < drops.length; i++) {
      const text = allWords[Math.floor(Math.random() * allWords.length)];
      const x = i * fontSize;
      const y = drops[i] * fontSize;

      // 1% clignote en rouge
      if (Math.random() < 0.01) {
        ctx.fillStyle = Math.random() < 0.5 ? "red" : "#FF0033";
      } else {
        ctx.fillStyle = palette[Math.floor(Math.random() * palette.length)];
      }

      ctx.fillText(text, x, y);

      if (y > canvas.height && Math.random() > 0.975) {
        drops[i] = 0;
      }
      drops[i]++;
    }
  }

  function startAsciiRain() {
    drops = Array(columns).fill(1);
    canvas.style.display = "block";
    asciiInterval = setInterval(drawRain, 60);
  }

  function stopAsciiRain() {
    clearInterval(asciiInterval);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    canvas.style.display = "none";
  }
</script>  
</body>
</html>
